name: Publish package to PyPI

on:
  workflow_dispatch:
    inputs:
      package:
        description: "Package(s) to publish. Single package: 'rai_core'. Multiple packages (comma-separated): 'rai_core,rai-perception,rai-bench'. See list-packages job output for available packages."
        required: true
        type: string
      publish_target:
        description: "Publish target"
        required: true
        type: choice
        options:
          - test-pypi
          - pypi
      build_wheels:
        description: "Build platform-specific wheels (required for packages with C extensions)"
        required: false
        type: boolean
        default: false

jobs:
  discover-packages:
    name: Discover packages and validate
    runs-on: ubuntu-latest
    outputs:
      packages_json: ${{ steps.discover.outputs.packages_json }}
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Discover and validate packages
        id: discover
        run: |
          python scripts/discover_packages.py --output-format json > packages.json
          
          # Parse comma-separated package list and validate
          PACKAGE_INPUT="${{ inputs.package }}"
          python -c "
          import json
          import subprocess
          import sys
          
          # Load discovered packages
          with open('packages.json') as f:
              all_packages = json.load(f)
          
          # Parse input packages (comma-separated)
          package_input = '$PACKAGE_INPUT'
          package_names = [p.strip() for p in package_input.split(',') if p.strip()]
          
          validated = []
          errors = []
          
          for pkg_name in package_names:
              if pkg_name not in all_packages:
                  errors.append(f\"Package '{pkg_name}' not found in repository\")
                  continue
              
              pkg_info = all_packages[pkg_name]
              validated.append({
                  'name': pkg_name,
                  'path': pkg_info['path'],
                  'version': pkg_info['version']
              })
              print(f\"Found package: {pkg_name} v{pkg_info['version']} at {pkg_info['path']}\")
          
          if errors:
              print('\\nErrors:', file=sys.stderr)
              for err in errors:
                  print(f'  - {err}', file=sys.stderr)
              print('\\nAvailable packages:', file=sys.stderr)
              for name in sorted(all_packages.keys()):
                  print(f'  - {name}', file=sys.stderr)
              sys.exit(1)
          
          # Check PyPI versions
          publish_target = '${{ inputs.publish_target }}'
          for pkg in validated:
              pkg_name = pkg['name']
              pkg_version = pkg['version']
              
              if publish_target == 'pypi':
                  result = subprocess.run(['python', 'scripts/check_pypi_version.py', pkg_name, pkg_version], 
                                        capture_output=True, text=True)
                  if result.returncode == 1:
                      print(f\"::error::Version {pkg_version} of {pkg_name} already exists on PyPI. Bump version in pyproject.toml before publishing.\", file=sys.stderr)
                      errors.append(f\"Version {pkg_version} of {pkg_name} already exists on PyPI\")
              else:
                  result = subprocess.run(['python', 'scripts/check_pypi_version.py', pkg_name, pkg_version, '--test-pypi'], 
                                        capture_output=True, text=True)
                  if result.returncode == 1:
                      print(f\"::warning::Version {pkg_version} of {pkg_name} already exists on Test PyPI\")
          
          if errors:
              sys.exit(1)
          
          # Output validated packages as JSON
          packages_json = json.dumps(validated)
          with open('$GITHUB_OUTPUT', 'a') as f:
              print(f'packages_json={packages_json}', file=f)
          print(f'Validated {len(validated)} package(s): {packages_json}')
          "

  build_wheels:
    name: Build wheels
    if: inputs.build_wheels == true
    runs-on: ubuntu-latest
    needs: [discover-packages]
    strategy:
      fail-fast: false
      matrix:
        package: ${{ fromJson(needs.discover-packages.outputs.packages_json) }}
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Install cibuildwheel
        run: python -m pip install cibuildwheel==2.16.2

      - name: Build wheels
        working-directory: ${{ matrix.package.path }}
        env:
          CIBW_BUILD: cp310-* cp312-*
          CIBW_SKIP: pp* *-win32 *-manylinux_i686
          CIBW_BEFORE_BUILD: |
            set -e
            # Upgrade pip first to ensure it can find pre-built wheels
            python -m pip install --upgrade pip wheel setuptools
            # Install Rust compiler for packages like tiktoken that need to build from source
            if ! command -v rustc &> /dev/null; then
              curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --default-toolchain stable
              export PATH="$HOME/.cargo/bin:$PATH"
            fi
            # Install Poetry
            python -m pip install poetry
            # Configure pip to prefer binary wheels over source builds
            export PIP_PREFER_BINARY=1
            # Only use Poetry if poetry.lock exists
            if [ -f poetry.lock ]; then
              # Install package dependencies - Poetry will use pre-built wheels when available
              poetry install --no-interaction --no-root --only main
            fi
          CIBW_BUILD_FRONTEND: build
          CIBW_PROJECT_REQUIRES_PYTHON: ">=3.10,<3.13"
          CIBW_MANYLINUX_X86_64_IMAGE: manylinux_2_28
          CIBW_MANYLINUX_AARCH64_IMAGE: manylinux_2_28
          CIBW_ENVIRONMENT: 'PATH="$HOME/.cargo/bin:$PATH"'
        run: |
          python -m cibuildwheel --output-dir wheelhouse

      - name: Upload wheels
        uses: actions/upload-artifact@v4
        with:
          name: wheels-${{ matrix.package.name }}
          path: ${{ matrix.package.path }}/wheelhouse/*.whl
          retention-days: 7

  build_sdist:
    name: Build source distributions
    runs-on: ubuntu-latest
    needs: [discover-packages]
    strategy:
      fail-fast: false
      matrix:
        package: ${{ fromJson(needs.discover-packages.outputs.packages_json) }}
    steps:
      - uses: actions/checkout@v4

      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: 2.1.1

      - name: Build source distribution
        working-directory: ${{ matrix.package.path }}
        run: |
          poetry build --format sdist

      - name: Upload source distribution
        uses: actions/upload-artifact@v4
        with:
          name: sdist-${{ matrix.package.name }}
          path: ${{ matrix.package.path }}/dist/*.tar.gz
          retention-days: 7

  publish_test_pypi:
    name: Publish to Test PyPI
    if: inputs.publish_target == 'test-pypi'
    runs-on: ubuntu-latest
    needs: [discover-packages, build_sdist]
    environment: test-pypi
    permissions:
      id-token: write

    steps:
      - uses: actions/checkout@v4

      - name: Download wheel artifacts
        if: inputs.build_wheels == true
        uses: actions/download-artifact@v4
        with:
          pattern: wheels-*
          merge-multiple: true
          path: wheels

      - name: Download all source distributions
        uses: actions/download-artifact@v4
        with:
          pattern: sdist-*
          merge-multiple: true
          path: dist

      - name: Publish to Test PyPI (with wheels)
        if: inputs.build_wheels == true
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          packages-dir: |
            wheels
            dist
          repository-url: https://test.pypi.org/legacy/

      - name: Publish to Test PyPI (sdist only)
        if: inputs.build_wheels == false
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          packages-dir: dist
          repository-url: https://test.pypi.org/legacy/

      - name: Verify installation from Test PyPI
        run: |
          PACKAGES_JSON='${{ needs.discover-packages.outputs.packages_json }}'
          PACKAGE_NAMES=$(python -c "import json, sys; pkgs = json.loads(sys.argv[1]); print(' '.join([p['name'] for p in pkgs]))" "$PACKAGES_JSON")
          pip install --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple/ $PACKAGE_NAMES
          echo "Packages published to Test PyPI: $PACKAGE_NAMES"

  publish_pypi:
    name: Publish to PyPI
    if: inputs.publish_target == 'pypi'
    runs-on: ubuntu-latest
    needs: [discover-packages, build_sdist]
    environment: pypi
    permissions:
      id-token: write

    steps:
      - uses: actions/checkout@v4

      - name: Download wheel artifacts
        if: inputs.build_wheels == true
        uses: actions/download-artifact@v4
        with:
          pattern: wheels-*
          merge-multiple: true
          path: wheels

      - name: Download all source distributions
        uses: actions/download-artifact@v4
        with:
          pattern: sdist-*
          merge-multiple: true
          path: dist

      - name: Publish to PyPI (with wheels)
        if: inputs.build_wheels == true
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          packages-dir: |
            wheels
            dist

      - name: Publish to PyPI (sdist only)
        if: inputs.build_wheels == false
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          packages-dir: dist

      - name: Verify installation from PyPI
        run: |
          PACKAGES_JSON='${{ needs.discover-packages.outputs.packages_json }}'
          PACKAGE_NAMES=$(python -c "import json, sys; pkgs = json.loads(sys.argv[1]); print(' '.join([p['name'] for p in pkgs]))" "$PACKAGES_JSON")
          pip install $PACKAGE_NAMES
          echo "Packages published to PyPI: $PACKAGE_NAMES"
